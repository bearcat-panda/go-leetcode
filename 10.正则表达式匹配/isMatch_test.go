package _0_æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…

import (
	"fmt"
	"log"
	"strings"
	"testing"
)

//ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸² s å’Œä¸€ä¸ªå­—ç¬¦è§„å¾‹ pï¼Œè¯·ä½ æ¥å®ç°ä¸€ä¸ªæ”¯æŒ '.' å’Œ '*' çš„æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…ã€‚
//
//
// '.' åŒ¹é…ä»»æ„å•ä¸ªå­—ç¬¦
// '*' åŒ¹é…é›¶ä¸ªæˆ–å¤šä¸ªå‰é¢çš„é‚£ä¸€ä¸ªå…ƒç´ 
//
//
// æ‰€è°“åŒ¹é…ï¼Œæ˜¯è¦æ¶µç›– æ•´ä¸ª å­—ç¬¦ä¸² sçš„ï¼Œè€Œä¸æ˜¯éƒ¨åˆ†å­—ç¬¦ä¸²ã€‚
//
//
// ç¤ºä¾‹ 1ï¼š
//
//
//è¾“å…¥ï¼šs = "aa" p = "a"
//è¾“å‡ºï¼šfalse
//è§£é‡Šï¼š"a" æ— æ³•åŒ¹é… "aa" æ•´ä¸ªå­—ç¬¦ä¸²ã€‚
//
//
// ç¤ºä¾‹ 2:
//
//
//è¾“å…¥ï¼šs = "aa" p = "a*"
//è¾“å‡ºï¼štrue
//è§£é‡Šï¼šå› ä¸º '*' ä»£è¡¨å¯ä»¥åŒ¹é…é›¶ä¸ªæˆ–å¤šä¸ªå‰é¢çš„é‚£ä¸€ä¸ªå…ƒç´ , åœ¨è¿™é‡Œå‰é¢çš„å…ƒç´ å°±æ˜¯ 'a'ã€‚å› æ­¤ï¼Œå­—ç¬¦ä¸² "aa" å¯è¢«è§†ä¸º 'a' é‡å¤äº†ä¸€æ¬¡ã€‚
//
//
// ç¤ºä¾‹ 3ï¼š
//
//
//è¾“å…¥ï¼šs = "ab" p = ".*"
//è¾“å‡ºï¼štrue
//è§£é‡Šï¼š".*" è¡¨ç¤ºå¯åŒ¹é…é›¶ä¸ªæˆ–å¤šä¸ªï¼ˆ'*'ï¼‰ä»»æ„å­—ç¬¦ï¼ˆ'.'ï¼‰ã€‚
//
//
// ç¤ºä¾‹ 4ï¼š
//
//
//è¾“å…¥ï¼šs = "aab" p = "c*a*b"
//è¾“å‡ºï¼štrue
//è§£é‡Šï¼šå› ä¸º '*' è¡¨ç¤ºé›¶ä¸ªæˆ–å¤šä¸ªï¼Œè¿™é‡Œ 'c' ä¸º 0 ä¸ª, 'a' è¢«é‡å¤ä¸€æ¬¡ã€‚å› æ­¤å¯ä»¥åŒ¹é…å­—ç¬¦ä¸² "aab"ã€‚
//
//
// ç¤ºä¾‹ 5ï¼š
//
//
//è¾“å…¥ï¼šs = "mississippi" p = "mis*is*p*."
//è¾“å‡ºï¼šfalse
//
//
//
// æç¤ºï¼š
//
//
// 0 <= s.length <= 20
// 0 <= p.length <= 30
// s å¯èƒ½ä¸ºç©ºï¼Œä¸”åªåŒ…å«ä» a-z çš„å°å†™å­—æ¯ã€‚
// p å¯èƒ½ä¸ºç©ºï¼Œä¸”åªåŒ…å«ä» a-z çš„å°å†™å­—æ¯ï¼Œä»¥åŠå­—ç¬¦ . å’Œ *ã€‚
// ä¿è¯æ¯æ¬¡å‡ºç°å­—ç¬¦ * æ—¶ï¼Œå‰é¢éƒ½åŒ¹é…åˆ°æœ‰æ•ˆçš„å­—ç¬¦
//
// Related Topics å­—ç¬¦ä¸² åŠ¨æ€è§„åˆ’ å›æº¯ç®—æ³•
// ğŸ‘ 1836 ğŸ‘ 0

func TestIsMatch(t *testing.T) {
	s, p := "aa", "a"
	fmt.Println(isMatch(s, p))

	s, p = "aa", "a*"
	fmt.Println(isMatch(s, p))

	s, p = "ab", ".*"
	fmt.Println(isMatch(s, p))
	s, p = "aab", "c*a*b"
	fmt.Println(isMatch(s, p))
	s, p = "mississippi", "mis*is*p*."
	fmt.Println(isMatch(s, p))
}

//leetcode submit region begin(Prohibit modification and deletion)

//leetcode submit region end(Prohibit modification and deletion)

/*è§£é¢˜æ€è·¯ï¼š
ä¸€æ­¥åˆ°ä½ç›´æ¥æŒ‰æ­£åˆ™è¡¨è¾¾å¼çš„å®ç°æ¥:ç”Ÿæˆæœ‰é™çŠ¶æ€æœº

çŠ¶æ€æœºèŠ‚ç‚¹è®¾è®¡:

è¯¥èŠ‚ç‚¹å­—ç¬¦
å­å­™èŠ‚ç‚¹ map
æœ¬èŠ‚ç‚¹æ˜¯å¦ä¸ºæœ€ç»ˆèŠ‚ç‚¹
æœ¬èŠ‚ç‚¹çš„æœ€å°é•¿åº¦ï¼Œå¦‚æœåé¢æºå¸¦ *âˆ—ï¼Œåˆ™è‡ªç”±é•¿åº¦ä¸º 00; å¦åˆ™ä¸º 11

ä½œè€…ï¼šqianjigui
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/regular-expression-matching/solution/yi-bu-dao-wei-zhi-jie-an-zheng-ze-biao-da-shi-de-s/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚*/

func debug(v ...interface{}) {
	log.Println(v...)
}

func toString(i interface{}) string { //è¾“å‡º
	switch i.(type) {
	case int:
		return fmt.Sprintf("%v", i)
	case string:
		return fmt.Sprintf("%v", i)
	case bool:
		return fmt.Sprintf("%v", i)
	default:
		return fmt.Sprintf("%p", i)
	}
}

func isMatch(s string, p string) bool {
	begin := new(Node)
	begin.C = '>'
	begin.Size = generatePattern(begin, p, 0)
	debug(begin.String())
	return check(begin, s, 0)
}

type Node struct {
	C        byte
	Parent   *Node            //çˆ¶èŠ‚ç‚¹
	Children map[byte][]*Node //å­èŠ‚ç‚¹
	End      bool
	Size     int
}

func (n *Node) String() string {
	return n.StringLevel(0, make(map[*Node]bool))
}

func (n *Node) StringLevel(level int, finishNodes map[*Node]bool) string {
	r := make([]string, 0)
	if n.End {
		r = append(r, fmt.Sprintf("  id%s{%v};", toString(n), string(n.C)))
	} else {
		r = append(r, fmt.Sprintf("  id%s(%v);", toString(n), string(n.C)))
	}
	finishNodes[n] = true
	for k, v := range n.Children {
		for _, c := range v {
			if _, ok := finishNodes[c]; !ok {
				r = append(r, c.StringLevel(level+1, finishNodes))
			}
			r = append(r, fmt.Sprintf("  id%s -- %s --> id%s;", toString(n), string(k), toString(c)))
		}
	}
	return strings.Join(r, "\n")
}

func (n *Node) Append(c byte, child *Node) {
	m := n.Children
	if m == nil {
		m = make(map[byte][]*Node)
		n.Children = m
	}
	list := m[c]
	if list == nil {
		list = make([]*Node, 0)
	}
	for _, v := range list {
		if v == child {
			m[c] = list
			return
		}
	}
	list = append(list, child)
	m[c] = list
}

func generatePattern(now *Node, str string, idx int) int {
	if len(str) <= idx {
		now.End = true
		return now.Size
	}
	vnow := now
	switch str[idx] {
	case '*':
		now.Size = 0
		now.Append(now.C, now)
	default:
		node := new(Node)
		node.C = str[idx]
		now.Append(str[idx], node)
		node.Parent = now
		node.Size = 1
		vnow = node
	}
	ret := generatePattern(vnow, str, idx+1)
	if ret == 0 {
		now.End = true
	}
	addParent := now
	for addParent.Parent != nil {
		if addParent.Size == 0 {
			debug(toString(vnow), " -> ", toString(addParent.Parent))
			addParent.Parent.Append(vnow.C, vnow)
			addParent = addParent.Parent
		} else {
			break
		}
	}
	return now.Size + ret
}

func check(now *Node, str string, idx int) bool {
	if len(str) <= idx {
		return now.End
	}
	list := now.Children['.']
	for _, v := range now.Children[str[idx]] {
		list = append(list, v)
	}
	for _, v := range list {
		r := check(v, str, idx+1)
		if r {
			return true
		}
	}
	return false
}

/*ä½œè€…ï¼šqianjigui
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/regular-expression-matching/solution/yi-bu-dao-wei-zhi-jie-an-zheng-ze-biao-da-shi-de-s/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚*/
